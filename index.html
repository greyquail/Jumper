<!DOCTYPE html>
<html>
<head>
    <title>Cosmic Jumper</title>
    <style>
        /* ... (keep existing styles the same) ... */
    </style>
</head>
<body>
    <!-- ... (keep existing HTML elements the same) ... -->

    <script>
        // Game Constants
        const PLAYER_SIZE = 50;
        const GRAVITY = 0.5;
        const JUMP_FORCE = -12;
        const PLATFORM_WIDTH = 100;
        const PLATFORM_HEIGHT = 20;
        
        // Visual Themes
        const THEMES = [
            {
                name: 'Cosmic',
                background: '#0f0c29',
                player: '#ff4d79',
                platforms: {
                    normal: '#2ecc71',
                    moving: '#4d79ff',
                    breakable: '#ff4d79'
                },
                stars: '#ffffff'
            },
            {
                name: 'Neon Jungle',
                background: '#001219',
                player: '#9b5de5',
                platforms: {
                    normal: '#00f5d4',
                    moving: '#f15bb5',
                    breakable: '#fee440'
                },
                stars: '#a8dadc'
            }
        ];
        let currentTheme = 0;

        // Game Variables
        let canvas, ctx;
        let gameRunning = false;
        let score = 0;
        let player = { /* ... (keep existing player object) ... */ };
        let platforms = [];
        let stars = [];
        let particles = [];
        let cameraY = 0;
        let keys = {};
        let touchControls = { /* ... (keep existing controls) ... */ };
        
        // Initialize Game
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            createStars(150);
            resetPlayer();
            createPlatforms(8);
            setupControls();
            
            document.getElementById('startBtn').addEventListener('click', startGame);
            document.getElementById('restartBtn').addEventListener('click', startGame);
            
            requestAnimationFrame(gameLoop);
        }

        // ... (keep resizeCanvas and resetPlayer same) ... 

        function createStars(count) {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height * 2, // Extend starfield
                    size: Math.random() * 3 + 1,
                    speed: Math.random() * 0.2 + 0.1,
                    alpha: Math.random() * 0.5 + 0.5
                });
            }
        }

        function createPlatforms(count) {
            platforms = [];
            let y = canvas.height - 100;
            
            for (let i = 0; i < count; i++) {
                const type = Math.random() > 0.8 ? 'moving' : Math.random() > 0.9 ? 'breakable' : 'normal';
                
                platforms.push({
                    x: Math.random() * (canvas.width - PLATFORM_WIDTH),
                    y: y,
                    width: PLATFORM_WIDTH,
                    height: PLATFORM_HEIGHT,
                    type: type,
                    dx: type === 'moving' ? (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1) : 0,
                    timer: type === 'breakable' ? 100 : 0,
                });
                
                y -= 150 + Math.random() * 100;
            }
        }

        // ... (keep setupControls same) ... 

        // MODIFIED CAMERA SYSTEM
        function update() {
            if (!gameRunning) return;

            // Player movement (same)
            
            // Camera follow
            if (player.y < cameraY + canvas.height * 0.3) {
                const diff = cameraY + canvas.height * 0.3 - player.y;
                cameraY -= diff;
            }

            // Generate new platforms when needed
            if (platforms[0].y > cameraY + canvas.height + 200) {
                platforms.shift();
                
                const type = Math.random() > 0.8 ? 'moving' : Math.random() > 0.9 ? 'breakable' : 'normal';
                
                platforms.push({
                    x: Math.random() * (canvas.width - PLATFORM_WIDTH),
                    y: platforms[platforms.length-1].y - 150 - Math.random() * 100,
                    width: PLATFORM_WIDTH,
                    height: PLATFORM_HEIGHT,
                    type: type,
                    dx: type === 'moving' ? (Math.random() * 2 + 1) * (Math.random() > 0.5 ? 1 : -1) : 0,
                    timer: type === 'breakable' ? 100 : 0,
                });
            }

            // Game over check
            if (player.y > cameraY + canvas.height + 100) {
                gameOver();
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background with current theme
            ctx.fillStyle = THEMES[currentTheme].background;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw stars with parallax
            stars.forEach(star => {
                const drawY = star.y - cameraY * star.speed;
                if (drawY > canvas.height + 50) star.y -= canvas.height * 2;
                
                ctx.fillStyle = `rgba(${hexToRgb(THEMES[currentTheme].stars)}, ${star.alpha})`;
                ctx.beginPath();
                ctx.arc(star.x, drawY, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw platforms
            platforms.forEach(plat => {
                const drawY = plat.y - cameraY;
                
                // Platform color from theme
                const color = plat.type === 'breakable' ? THEMES[currentTheme].platforms.breakable : 
                            plat.type === 'moving' ? THEMES[currentTheme].platforms.moving : 
                            THEMES[currentTheme].platforms.normal;

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.roundRect(plat.x, drawY, plat.width, plat.height, 10);
                ctx.fill();
            });

            // Draw player relative to camera
            drawPlayer(player.x, player.y - cameraY);

            // ... (rest of rendering code) ... 
        }

        function drawPlayer(x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // Player body with theme color
            ctx.fillStyle = THEMES[currentTheme].player;
            ctx.beginPath();
            ctx.arc(PLAYER_SIZE/2, PLAYER_SIZE/2, PLAYER_SIZE/2, 0, Math.PI*2);
            ctx.fill();
            
            // ... (rest of player drawing code) ... 
        }

        // Helper function to convert hex to RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1,3), 16);
            const g = parseInt(hex.slice(3,5), 16);
            const b = parseInt(hex.slice(5,7), 16);
            return `${r}, ${g}, ${b}`;
        }

        // ... (keep rest of the code same) ... 
    </script>
</body>
</html>
